/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.3.0 (NJsonSchema v9.13.35.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class BlServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    getAll(): Observable<Bl[] | null> {
        let url_ = this.baseUrl + "/api/bl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Bl[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Bl[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Bl[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Bl.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Bl[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    post(value: Bl | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/bl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    get(startDate: Date | null, endDate: Date | null, filter: Bl | null): Observable<Bl[] | null> {
        let url_ = this.baseUrl + "/api/bl/period?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Bl[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Bl[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Bl[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Bl.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Bl[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getVins(blNo: string): Observable<Vin[] | null> {
        let url_ = this.baseUrl + "/api/bl/{blNo}/vins";
        if (blNo === undefined || blNo === null)
            throw new Error("The parameter 'blNo' must be defined.");
        url_ = url_.replace("{blNo}", encodeURIComponent("" + blNo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVins(<any>response_);
                } catch (e) {
                    return <Observable<Vin[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Vin[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetVins(response: HttpResponseBase): Observable<Vin[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Vin.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Vin[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getVessel(startDate: Date | null, endDate: Date | null, filter: Bl | null): Observable<Vessel[] | null> {
        let url_ = this.baseUrl + "/api/bl/vessel?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVessel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVessel(<any>response_);
                } catch (e) {
                    return <Observable<Vessel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Vessel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetVessel(response: HttpResponseBase): Observable<Vessel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Vessel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Vessel[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getPort(startDate: Date | null, endDate: Date | null, filter: Bl | null): Observable<Port[] | null> {
        let url_ = this.baseUrl + "/api/bl/port?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPort(<any>response_);
                } catch (e) {
                    return <Observable<Port[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Port[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPort(response: HttpResponseBase): Observable<Port[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Port.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Port[] | null>(<any>null);
    }
}

@Injectable()
export class ErrorCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    getAll(): Observable<ErrorCode[] | null> {
        let url_ = this.baseUrl + "/api/errorcode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ErrorCode[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ErrorCode[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ErrorCode[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ErrorCode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ErrorCode[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    post(value: ErrorCode | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/errorcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    put(value: ErrorCode | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/errorcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    get(id: string): Observable<ErrorCode[] | null> {
        let url_ = this.baseUrl + "/api/errorcode/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ErrorCode[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ErrorCode[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ErrorCode[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ErrorCode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ErrorCode[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    delete(code: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/errorcode/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class HelloServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    get(): Observable<string | null> {
        let url_ = this.baseUrl + "/api/Hello";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<string | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<string | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string | null>(<any>null);
    }
}

@Injectable()
export class IHubServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    inbouhnd(): Observable<void> {
        let url_ = this.baseUrl + "/api/ihub/inbound";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInbouhnd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInbouhnd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInbouhnd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    outbouhnd(): Observable<void> {
        let url_ = this.baseUrl + "/api/ihub/outbound";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutbouhnd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutbouhnd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOutbouhnd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    authenticate(login: Authenticate | null): Observable<AuthenticateResult | null> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResult | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResult | null>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResult | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResult.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = resultData401 !== undefined ? resultData401 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResult | null>(<any>null);
    }
}

@Injectable()
export class PaymentRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    get(startDate: Date | null, endDate: Date | null, prFilter: PaymentRequest | null): Observable<PaymentRequest[] | null> {
        let url_ = this.baseUrl + "/api/paymentrequest?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(prFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaymentRequest[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentRequest[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentRequest[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentRequest.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentRequest[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getInit(startDate: Date | null, endDate: Date | null, bl: Bl | null): Observable<PaymentRequest[] | null> {
        let url_ = this.baseUrl + "/api/paymentrequest/init?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInit(<any>response_);
                } catch (e) {
                    return <Observable<PaymentRequest[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentRequest[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetInit(response: HttpResponseBase): Observable<PaymentRequest[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentRequest.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentRequest[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getRevision(startDate: Date | null, endDate: Date | null, bl: Bl | null): Observable<PaymentRequest[] | null> {
        let url_ = this.baseUrl + "/api/paymentrequest/revision?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRevision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRevision(<any>response_);
                } catch (e) {
                    return <Observable<PaymentRequest[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentRequest[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetRevision(response: HttpResponseBase): Observable<PaymentRequest[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentRequest.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentRequest[] | null>(<any>null);
    }
}

@Injectable()
export class PaymentRejectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    get(startDate: Date | null, endDate: Date | null, bl: Bl | null, isOpenOnly: boolean): Observable<PaymentRejection[] | null> {
        let url_ = this.baseUrl + "/api/paymentrejection?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (isOpenOnly === undefined || isOpenOnly === null)
            throw new Error("The parameter 'isOpenOnly' must be defined and cannot be null.");
        else
            url_ += "isOpenOnly=" + encodeURIComponent("" + isOpenOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaymentRejection[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentRejection[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentRejection[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentRejection.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentRejection[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getVoyage(startDate: Date | null, endDate: Date | null, bl: Bl | null, isOpenOnly: boolean): Observable<Bl[] | null> {
        let url_ = this.baseUrl + "/api/paymentrejection/voyage?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (isOpenOnly === undefined || isOpenOnly === null)
            throw new Error("The parameter 'isOpenOnly' must be defined and cannot be null.");
        else
            url_ += "isOpenOnly=" + encodeURIComponent("" + isOpenOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVoyage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoyage(<any>response_);
                } catch (e) {
                    return <Observable<Bl[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Bl[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetVoyage(response: HttpResponseBase): Observable<Bl[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Bl.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Bl[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    updateStatus(bl: Bl | null, errorCode: string | null, status: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/paymentrejection/updatestatus/vesselvoyage?";
        if (errorCode === undefined)
            throw new Error("The parameter 'errorCode' must be defined.");
        else
            url_ += "errorCode=" + encodeURIComponent("" + errorCode) + "&"; 
        if (status === undefined)
            throw new Error("The parameter 'status' must be defined.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    updateStatus2(rejection: PaymentRejection | null, status: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/paymentrejection/updatestatus/vinseq?";
        if (status === undefined)
            throw new Error("The parameter 'status' must be defined.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rejection);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus2(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus2(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    sendRequest(errorCode: string | null, request: PaymentRequest | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/paymentrejection/sendrequest?";
        if (errorCode === undefined)
            throw new Error("The parameter 'errorCode' must be defined.");
        else
            url_ += "errorCode=" + encodeURIComponent("" + errorCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendRequest(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendRequest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    getPayment(startDate: Date | null, endDate: Date | null, filter: Bl | null, checkNumber: string | null): Observable<Payment[] | null> {
        let url_ = this.baseUrl + "/api/payment?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (checkNumber === undefined)
            throw new Error("The parameter 'checkNumber' must be defined.");
        else
            url_ += "checkNumber=" + encodeURIComponent("" + checkNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<Payment[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Payment[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<Payment[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Payment.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Payment[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getPaymentEntries(voucherRef: string): Observable<PaymentEntry[] | null> {
        let url_ = this.baseUrl + "/api/payment/{voucherRef}/entry";
        if (voucherRef === undefined || voucherRef === null)
            throw new Error("The parameter 'voucherRef' must be defined.");
        url_ = url_.replace("{voucherRef}", encodeURIComponent("" + voucherRef)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentEntries(<any>response_);
                } catch (e) {
                    return <Observable<PaymentEntry[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentEntry[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentEntries(response: HttpResponseBase): Observable<PaymentEntry[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentEntry.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentEntry[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getPaymentChecks(voucherRef: string, filter: Bl | null): Observable<PaymentEntry[] | null> {
        let url_ = this.baseUrl + "/api/payment/{voucherRef}/check";
        if (voucherRef === undefined || voucherRef === null)
            throw new Error("The parameter 'voucherRef' must be defined.");
        url_ = url_.replace("{voucherRef}", encodeURIComponent("" + voucherRef)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentChecks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentChecks(<any>response_);
                } catch (e) {
                    return <Observable<PaymentEntry[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentEntry[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentChecks(response: HttpResponseBase): Observable<PaymentEntry[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentEntry.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentEntry[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getCheck(startDate: Date | null, endDate: Date | null, filter: Bl | null): Observable<PaymentEntry[] | null> {
        let url_ = this.baseUrl + "/api/check?";
        if (startDate === undefined)
            throw new Error("The parameter 'startDate' must be defined.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined)
            throw new Error("The parameter 'endDate' must be defined.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheck(<any>response_);
                } catch (e) {
                    return <Observable<PaymentEntry[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentEntry[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheck(response: HttpResponseBase): Observable<PaymentEntry[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentEntry.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentEntry[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    getPaymentEntriesByCheck(checkNumber: string | null, filterBl: Bl | null): Observable<PaymentEntry[] | null> {
        let url_ = this.baseUrl + "/api/check/entry?";
        if (checkNumber === undefined)
            throw new Error("The parameter 'checkNumber' must be defined.");
        else
            url_ += "checkNumber=" + encodeURIComponent("" + checkNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterBl);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentEntriesByCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentEntriesByCheck(<any>response_);
                } catch (e) {
                    return <Observable<PaymentEntry[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentEntry[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentEntriesByCheck(response: HttpResponseBase): Observable<PaymentEntry[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentEntry.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentEntry[] | null>(<any>null);
    }
}

@Injectable()
export class PortServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    getAll(): Observable<Port[] | null> {
        let url_ = this.baseUrl + "/api/port";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Port[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Port[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Port[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Port.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Port[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    post(value: Port | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/port";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return ok
     */
    get(code: string): Observable<Port[] | null> {
        let url_ = this.baseUrl + "/api/port/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Port[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Port[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Port[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Port.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Port[] | null>(<any>null);
    }

    /**
     * @return ok
     */
    delete(code: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/port/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PrestoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:59866";
    }

    /**
     * @return ok
     */
    upLoad(values: Presto[] | null): Observable<PrestoResponse | null> {
        let url_ = this.baseUrl + "/api/Presto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpLoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpLoad(<any>response_);
                } catch (e) {
                    return <Observable<PrestoResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrestoResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpLoad(response: HttpResponseBase): Observable<PrestoResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PrestoResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? Exception.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrestoResponse | null>(<any>null);
    }
}

export class Bl implements IBl {
    number: string;
    firstLegLoadPort: string | undefined;
    lastLegDischargePort: string | undefined;
    firstLegVesselCode: string | undefined;
    firstLegVoyageNumber: string | undefined;
    lastLegVesselCode: string | undefined;
    lastLegVoyageNumber: string | undefined;
    lastLegDischargeDate: Date | undefined;
    firstLegLoadPortName: string | undefined;
    lastLegDischargePortName: string | undefined;
    firstLegVesselName: string | undefined;
    lastLegVesselName: string | undefined;
    firstLegLoadPortRamp: string | undefined;
    lastLegDischargePortRamp: string | undefined;
    vinCount: number;

    constructor(data?: IBl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.number = data["Number"];
            this.firstLegLoadPort = data["FirstLegLoadPort"];
            this.lastLegDischargePort = data["LastLegDischargePort"];
            this.firstLegVesselCode = data["FirstLegVesselCode"];
            this.firstLegVoyageNumber = data["FirstLegVoyageNumber"];
            this.lastLegVesselCode = data["LastLegVesselCode"];
            this.lastLegVoyageNumber = data["LastLegVoyageNumber"];
            this.lastLegDischargeDate = data["LastLegDischargeDate"] ? new Date(data["LastLegDischargeDate"].toString()) : <any>undefined;
            this.firstLegLoadPortName = data["FirstLegLoadPortName"];
            this.lastLegDischargePortName = data["LastLegDischargePortName"];
            this.firstLegVesselName = data["FirstLegVesselName"];
            this.lastLegVesselName = data["LastLegVesselName"];
            this.firstLegLoadPortRamp = data["FirstLegLoadPortRamp"];
            this.lastLegDischargePortRamp = data["LastLegDischargePortRamp"];
            this.vinCount = data["VinCount"];
        }
    }

    static fromJS(data: any): Bl {
        data = typeof data === 'object' ? data : {};
        let result = new Bl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Number"] = this.number;
        data["FirstLegLoadPort"] = this.firstLegLoadPort;
        data["LastLegDischargePort"] = this.lastLegDischargePort;
        data["FirstLegVesselCode"] = this.firstLegVesselCode;
        data["FirstLegVoyageNumber"] = this.firstLegVoyageNumber;
        data["LastLegVesselCode"] = this.lastLegVesselCode;
        data["LastLegVoyageNumber"] = this.lastLegVoyageNumber;
        data["LastLegDischargeDate"] = this.lastLegDischargeDate ? this.lastLegDischargeDate.toISOString() : <any>undefined;
        data["FirstLegLoadPortName"] = this.firstLegLoadPortName;
        data["LastLegDischargePortName"] = this.lastLegDischargePortName;
        data["FirstLegVesselName"] = this.firstLegVesselName;
        data["LastLegVesselName"] = this.lastLegVesselName;
        data["FirstLegLoadPortRamp"] = this.firstLegLoadPortRamp;
        data["LastLegDischargePortRamp"] = this.lastLegDischargePortRamp;
        data["VinCount"] = this.vinCount;
        return data; 
    }

    clone(): Bl {
        const json = this.toJSON();
        let result = new Bl();
        result.init(json);
        return result;
    }
}

export interface IBl {
    number: string;
    firstLegLoadPort: string | undefined;
    lastLegDischargePort: string | undefined;
    firstLegVesselCode: string | undefined;
    firstLegVoyageNumber: string | undefined;
    lastLegVesselCode: string | undefined;
    lastLegVoyageNumber: string | undefined;
    lastLegDischargeDate: Date | undefined;
    firstLegLoadPortName: string | undefined;
    lastLegDischargePortName: string | undefined;
    firstLegVesselName: string | undefined;
    lastLegVesselName: string | undefined;
    firstLegLoadPortRamp: string | undefined;
    lastLegDischargePortRamp: string | undefined;
    vinCount: number;
}

export class Exception implements IException {
    message: string | undefined;
    innerException: Exception | undefined;
    stackTrace: string | undefined;
    source: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            this.innerException = data["InnerException"] ? Exception.fromJS(data["InnerException"]) : <any>undefined;
            this.stackTrace = data["StackTrace"];
            this.source = data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Source"] = this.source;
        return data; 
    }

    clone(): Exception {
        const json = this.toJSON();
        let result = new Exception();
        result.init(json);
        return result;
    }
}

export interface IException {
    message: string | undefined;
    innerException: Exception | undefined;
    stackTrace: string | undefined;
    source: string | undefined;
}

export class Vin implements IVin {
    vinNo: string;
    blNo: string;

    constructor(data?: IVin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vinNo = data["VinNo"];
            this.blNo = data["BlNo"];
        }
    }

    static fromJS(data: any): Vin {
        data = typeof data === 'object' ? data : {};
        let result = new Vin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VinNo"] = this.vinNo;
        data["BlNo"] = this.blNo;
        return data; 
    }

    clone(): Vin {
        const json = this.toJSON();
        let result = new Vin();
        result.init(json);
        return result;
    }
}

export interface IVin {
    vinNo: string;
    blNo: string;
}

export class Vessel implements IVessel {
    vesselCode: string | undefined;
    vesselName: string | undefined;

    constructor(data?: IVessel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vesselCode = data["VesselCode"];
            this.vesselName = data["VesselName"];
        }
    }

    static fromJS(data: any): Vessel {
        data = typeof data === 'object' ? data : {};
        let result = new Vessel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VesselCode"] = this.vesselCode;
        data["VesselName"] = this.vesselName;
        return data; 
    }

    clone(): Vessel {
        const json = this.toJSON();
        let result = new Vessel();
        result.init(json);
        return result;
    }
}

export interface IVessel {
    vesselCode: string | undefined;
    vesselName: string | undefined;
}

export class Port implements IPort {
    portCode: string;
    portName: string | undefined;
    country: string | undefined;
    rampCode: string;

    constructor(data?: IPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.portCode = data["PortCode"];
            this.portName = data["PortName"];
            this.country = data["Country"];
            this.rampCode = data["RampCode"];
        }
    }

    static fromJS(data: any): Port {
        data = typeof data === 'object' ? data : {};
        let result = new Port();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PortCode"] = this.portCode;
        data["PortName"] = this.portName;
        data["Country"] = this.country;
        data["RampCode"] = this.rampCode;
        return data; 
    }

    clone(): Port {
        const json = this.toJSON();
        let result = new Port();
        result.init(json);
        return result;
    }
}

export interface IPort {
    portCode: string;
    portName: string | undefined;
    country: string | undefined;
    rampCode: string;
}

export class ErrorCode implements IErrorCode {
    code: string;
    definition: string;
    description: string | undefined;

    constructor(data?: IErrorCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["Code"];
            this.definition = data["Definition"];
            this.description = data["Description"];
        }
    }

    static fromJS(data: any): ErrorCode {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Definition"] = this.definition;
        data["Description"] = this.description;
        return data; 
    }

    clone(): ErrorCode {
        const json = this.toJSON();
        let result = new ErrorCode();
        result.init(json);
        return result;
    }
}

export interface IErrorCode {
    code: string;
    definition: string;
    description: string | undefined;
}

export class AuthenticateResult implements IAuthenticateResult {
    accessToken: string | undefined;
    responseMsg: any | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["AccessToken"];
            this.responseMsg = data["ResponseMsg"];
            this.encryptedAccessToken = data["EncryptedAccessToken"];
            this.expireInSeconds = data["ExpireInSeconds"];
            this.userId = data["UserId"];
        }
    }

    static fromJS(data: any): AuthenticateResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccessToken"] = this.accessToken;
        data["ResponseMsg"] = this.responseMsg;
        data["EncryptedAccessToken"] = this.encryptedAccessToken;
        data["ExpireInSeconds"] = this.expireInSeconds;
        data["UserId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResult {
        const json = this.toJSON();
        let result = new AuthenticateResult();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResult {
    accessToken: string | undefined;
    responseMsg: any | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class Authenticate implements IAuthenticate {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["UserNameOrEmailAddress"];
            this.password = data["Password"];
            this.rememberClient = data["RememberClient"];
        }
    }

    static fromJS(data: any): Authenticate {
        data = typeof data === 'object' ? data : {};
        let result = new Authenticate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["Password"] = this.password;
        data["RememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): Authenticate {
        const json = this.toJSON();
        let result = new Authenticate();
        result.init(json);
        return result;
    }
}

export interface IAuthenticate {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class PaymentRequest implements IPaymentRequest {
    seqNo: number;
    recordType: string | undefined;
    vin: string | undefined;
    bl: Bl | undefined;
    status: string | undefined;
    exceptionCode: string | undefined;
    exceptionAuthCode: string | undefined;
    chargeToCode: string | undefined;

    constructor(data?: IPaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seqNo = data["SeqNo"];
            this.recordType = data["RecordType"];
            this.vin = data["Vin"];
            this.bl = data["Bl"] ? Bl.fromJS(data["Bl"]) : <any>undefined;
            this.status = data["Status"];
            this.exceptionCode = data["ExceptionCode"];
            this.exceptionAuthCode = data["ExceptionAuthCode"];
            this.chargeToCode = data["ChargeToCode"];
        }
    }

    static fromJS(data: any): PaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SeqNo"] = this.seqNo;
        data["RecordType"] = this.recordType;
        data["Vin"] = this.vin;
        data["Bl"] = this.bl ? this.bl.toJSON() : <any>undefined;
        data["Status"] = this.status;
        data["ExceptionCode"] = this.exceptionCode;
        data["ExceptionAuthCode"] = this.exceptionAuthCode;
        data["ChargeToCode"] = this.chargeToCode;
        return data; 
    }

    clone(): PaymentRequest {
        const json = this.toJSON();
        let result = new PaymentRequest();
        result.init(json);
        return result;
    }
}

export interface IPaymentRequest {
    seqNo: number;
    recordType: string | undefined;
    vin: string | undefined;
    bl: Bl | undefined;
    status: string | undefined;
    exceptionCode: string | undefined;
    exceptionAuthCode: string | undefined;
    chargeToCode: string | undefined;
}

export class PaymentRejection implements IPaymentRejection {
    recordType: string | undefined;
    vin: string | undefined;
    seqNo: number;
    status: string | undefined;
    exceptionCode: string | undefined;
    errorCode: string | undefined;
    bl: Bl | undefined;

    constructor(data?: IPaymentRejection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordType = data["RecordType"];
            this.vin = data["Vin"];
            this.seqNo = data["SeqNo"];
            this.status = data["Status"];
            this.exceptionCode = data["ExceptionCode"];
            this.errorCode = data["ErrorCode"];
            this.bl = data["Bl"] ? Bl.fromJS(data["Bl"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRejection {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRejection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RecordType"] = this.recordType;
        data["Vin"] = this.vin;
        data["SeqNo"] = this.seqNo;
        data["Status"] = this.status;
        data["ExceptionCode"] = this.exceptionCode;
        data["ErrorCode"] = this.errorCode;
        data["Bl"] = this.bl ? this.bl.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PaymentRejection {
        const json = this.toJSON();
        let result = new PaymentRejection();
        result.init(json);
        return result;
    }
}

export interface IPaymentRejection {
    recordType: string | undefined;
    vin: string | undefined;
    seqNo: number;
    status: string | undefined;
    exceptionCode: string | undefined;
    errorCode: string | undefined;
    bl: Bl | undefined;
}

export class Payment implements IPayment {
    voucherRef: string | undefined;
    voucherAmount: number;
    currency: string | undefined;
    unit: number;
    railCarId: string | undefined;
    createTime: Date;
    check: PaymentRemittance | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.voucherRef = data["VoucherRef"];
            this.voucherAmount = data["VoucherAmount"];
            this.currency = data["Currency"];
            this.unit = data["Unit"];
            this.railCarId = data["RailCarId"];
            this.createTime = data["CreateTime"] ? new Date(data["CreateTime"].toString()) : <any>undefined;
            this.check = data["Check"] ? PaymentRemittance.fromJS(data["Check"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VoucherRef"] = this.voucherRef;
        data["VoucherAmount"] = this.voucherAmount;
        data["Currency"] = this.currency;
        data["Unit"] = this.unit;
        data["RailCarId"] = this.railCarId;
        data["CreateTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["Check"] = this.check ? this.check.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Payment {
        const json = this.toJSON();
        let result = new Payment();
        result.init(json);
        return result;
    }
}

export interface IPayment {
    voucherRef: string | undefined;
    voucherAmount: number;
    currency: string | undefined;
    unit: number;
    railCarId: string | undefined;
    createTime: Date;
    check: PaymentRemittance | undefined;
}

export class PaymentRemittance implements IPaymentRemittance {
    paymentRemittanceId: string | undefined;
    paymentId: string | undefined;
    checkNumber: string | undefined;
    checkDate: Date | undefined;
    checkAmount: number;

    constructor(data?: IPaymentRemittance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentRemittanceId = data["PaymentRemittanceId"];
            this.paymentId = data["PaymentId"];
            this.checkNumber = data["CheckNumber"];
            this.checkDate = data["CheckDate"] ? new Date(data["CheckDate"].toString()) : <any>undefined;
            this.checkAmount = data["CheckAmount"];
        }
    }

    static fromJS(data: any): PaymentRemittance {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRemittance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaymentRemittanceId"] = this.paymentRemittanceId;
        data["PaymentId"] = this.paymentId;
        data["CheckNumber"] = this.checkNumber;
        data["CheckDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["CheckAmount"] = this.checkAmount;
        return data; 
    }

    clone(): PaymentRemittance {
        const json = this.toJSON();
        let result = new PaymentRemittance();
        result.init(json);
        return result;
    }
}

export interface IPaymentRemittance {
    paymentRemittanceId: string | undefined;
    paymentId: string | undefined;
    checkNumber: string | undefined;
    checkDate: Date | undefined;
    checkAmount: number;
}

export class PaymentEntry implements IPaymentEntry {
    paymentEntryId: string | undefined;
    paymentId: string | undefined;
    voucherRef: string | undefined;
    vin: string | undefined;
    deliveryStatus: string | undefined;
    seqNo: string | undefined;
    itemAmount: number;
    tariffNumber: string | undefined;
    sectionNumber: string | undefined;
    itemNumber: string | undefined;
    checkNumber: string | undefined;
    checkDate: Date | undefined;
    blNo: string | undefined;
    lastLegDischargePortName: string | undefined;

    constructor(data?: IPaymentEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentEntryId = data["PaymentEntryId"];
            this.paymentId = data["PaymentId"];
            this.voucherRef = data["VoucherRef"];
            this.vin = data["Vin"];
            this.deliveryStatus = data["DeliveryStatus"];
            this.seqNo = data["SeqNo"];
            this.itemAmount = data["ItemAmount"];
            this.tariffNumber = data["TariffNumber"];
            this.sectionNumber = data["SectionNumber"];
            this.itemNumber = data["ItemNumber"];
            this.checkNumber = data["CheckNumber"];
            this.checkDate = data["CheckDate"] ? new Date(data["CheckDate"].toString()) : <any>undefined;
            this.blNo = data["BlNo"];
            this.lastLegDischargePortName = data["LastLegDischargePortName"];
        }
    }

    static fromJS(data: any): PaymentEntry {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaymentEntryId"] = this.paymentEntryId;
        data["PaymentId"] = this.paymentId;
        data["VoucherRef"] = this.voucherRef;
        data["Vin"] = this.vin;
        data["DeliveryStatus"] = this.deliveryStatus;
        data["SeqNo"] = this.seqNo;
        data["ItemAmount"] = this.itemAmount;
        data["TariffNumber"] = this.tariffNumber;
        data["SectionNumber"] = this.sectionNumber;
        data["ItemNumber"] = this.itemNumber;
        data["CheckNumber"] = this.checkNumber;
        data["CheckDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["BlNo"] = this.blNo;
        data["LastLegDischargePortName"] = this.lastLegDischargePortName;
        return data; 
    }

    clone(): PaymentEntry {
        const json = this.toJSON();
        let result = new PaymentEntry();
        result.init(json);
        return result;
    }
}

export interface IPaymentEntry {
    paymentEntryId: string | undefined;
    paymentId: string | undefined;
    voucherRef: string | undefined;
    vin: string | undefined;
    deliveryStatus: string | undefined;
    seqNo: string | undefined;
    itemAmount: number;
    tariffNumber: string | undefined;
    sectionNumber: string | undefined;
    itemNumber: string | undefined;
    checkNumber: string | undefined;
    checkDate: Date | undefined;
    blNo: string | undefined;
    lastLegDischargePortName: string | undefined;
}

export class PrestoResponse implements IPrestoResponse {
    isSuccessed: boolean;
    message: string | undefined;
    errorRslt: PrestoError[] | undefined;

    constructor(data?: IPrestoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSuccessed = data["IsSuccessed"];
            this.message = data["Message"];
            if (data["ErrorRslt"] && data["ErrorRslt"].constructor === Array) {
                this.errorRslt = [] as any;
                for (let item of data["ErrorRslt"])
                    this.errorRslt.push(PrestoError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrestoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PrestoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsSuccessed"] = this.isSuccessed;
        data["Message"] = this.message;
        if (this.errorRslt && this.errorRslt.constructor === Array) {
            data["ErrorRslt"] = [];
            for (let item of this.errorRslt)
                data["ErrorRslt"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PrestoResponse {
        const json = this.toJSON();
        let result = new PrestoResponse();
        result.init(json);
        return result;
    }
}

export interface IPrestoResponse {
    isSuccessed: boolean;
    message: string | undefined;
    errorRslt: PrestoError[] | undefined;
}

export class PrestoError implements IPrestoError {
    error_Code: PrestoErrorCode;
    vin: string | undefined;
    fieldValue: string | undefined;

    constructor(data?: IPrestoError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.error_Code = data["Error_Code"];
            this.vin = data["Vin"];
            this.fieldValue = data["FieldValue"];
        }
    }

    static fromJS(data: any): PrestoError {
        data = typeof data === 'object' ? data : {};
        let result = new PrestoError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Error_Code"] = this.error_Code;
        data["Vin"] = this.vin;
        data["FieldValue"] = this.fieldValue;
        return data; 
    }

    clone(): PrestoError {
        const json = this.toJSON();
        let result = new PrestoError();
        result.init(json);
        return result;
    }
}

export interface IPrestoError {
    error_Code: PrestoErrorCode;
    vin: string | undefined;
    fieldValue: string | undefined;
}

export enum PrestoErrorCode {
    InvalidVin = 0, 
    InvalidPort = 1, 
    InvalidVessel = 2, 
}

export class Presto implements IPresto {
    vin: string | undefined;
    bl: string | undefined;
    firstLegVesselCode: string | undefined;
    firstLegVoyageNumber: number;
    firstLegLoadPort: string | undefined;
    lastLegVesselCode: string | undefined;
    lastLegVoyageNumber: number;
    lastLegDischargePort: string | undefined;

    constructor(data?: IPresto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vin = data["Vin"];
            this.bl = data["Bl"];
            this.firstLegVesselCode = data["FirstLegVesselCode"];
            this.firstLegVoyageNumber = data["FirstLegVoyageNumber"];
            this.firstLegLoadPort = data["FirstLegLoadPort"];
            this.lastLegVesselCode = data["LastLegVesselCode"];
            this.lastLegVoyageNumber = data["LastLegVoyageNumber"];
            this.lastLegDischargePort = data["LastLegDischargePort"];
        }
    }

    static fromJS(data: any): Presto {
        data = typeof data === 'object' ? data : {};
        let result = new Presto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Vin"] = this.vin;
        data["Bl"] = this.bl;
        data["FirstLegVesselCode"] = this.firstLegVesselCode;
        data["FirstLegVoyageNumber"] = this.firstLegVoyageNumber;
        data["FirstLegLoadPort"] = this.firstLegLoadPort;
        data["LastLegVesselCode"] = this.lastLegVesselCode;
        data["LastLegVoyageNumber"] = this.lastLegVoyageNumber;
        data["LastLegDischargePort"] = this.lastLegDischargePort;
        return data; 
    }

    clone(): Presto {
        const json = this.toJSON();
        let result = new Presto();
        result.init(json);
        return result;
    }
}

export interface IPresto {
    vin: string | undefined;
    bl: string | undefined;
    firstLegVesselCode: string | undefined;
    firstLegVoyageNumber: number;
    firstLegLoadPort: string | undefined;
    lastLegVesselCode: string | undefined;
    lastLegVoyageNumber: number;
    lastLegDischargePort: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}